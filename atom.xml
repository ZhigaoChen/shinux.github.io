<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sinux</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-12-17T10:45:29.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Sinux</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Iterative to Recursive</title>
    <link href="http://yoursite.com/2016/12/17/iterative_to_recursive/"/>
    <id>http://yoursite.com/2016/12/17/iterative_to_recursive/</id>
    <published>2016-12-17T15:46:16.000Z</published>
    <updated>2016-12-17T10:45:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>powerset 翻译成中文似乎是幂集，密集恐惧症患者搜索的时候要小心搜索引擎动态加载出来的图片。</p>
<blockquote>
<p>用 Racket 递归实现 powerset , 顺序随意。</p>
</blockquote>
<p>如果说 reduce 是一种折叠操作，powerset 就有点类似向右展开的操作，首先想到的是用 Python 实现:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">powerset</span><span class="params">(_list)</span>:</span></div><div class="line">    result = [[]]</div><div class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> _list:</div><div class="line">        result.extend([_set + [x] <span class="keyword">for</span> _set <span class="keyword">in</span> result])</div><div class="line">    <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<p>太美了……当然题目要求用 Racket ，而且要求使用递归，而不是循环。</p>
<p>所以先翻译成循环的 Racket 版本:</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">powerset</span> l)</div><div class="line">  (<span class="name"><span class="builtin-name">define</span></span> result '(()))</div><div class="line">  (<span class="name">for</span> ([<span class="name">x</span> l])</div><div class="line">    (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">temp-l</span> '()])</div><div class="line">      (<span class="name">for</span> ([<span class="name">y</span> result])</div><div class="line">        (<span class="name"><span class="builtin-name">set!</span></span> temp-l (<span class="name"><span class="builtin-name">append</span></span> temp-l (<span class="name"><span class="builtin-name">list</span></span> (<span class="name"><span class="builtin-name">append</span></span> y (<span class="name"><span class="builtin-name">list</span></span> x))))))</div><div class="line">      (<span class="name"><span class="builtin-name">set!</span></span> result (<span class="name"><span class="builtin-name">append</span></span> result temp-l))))</div><div class="line">  result)</div></pre></td></tr></table></figure>
<p>基本上就是剥离了 list.extend 和 list comprehension 等 Python 内置方法，用 Racket 重写了一遍。其实循环挺好的，（对我来说）大部分场景比递归更直观，而且由于 Python 没有尾递归优化，导致我在很长一段的时间里不敢轻易在 Python 中使用递归233333。</p>
<p>把上面的循环改写成递归：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">powerset</span> l [<span class="name">result</span> '(())])</div><div class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> l) result</div><div class="line">      (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">temp-l</span> '()])</div><div class="line">        (<span class="name">for</span> ([<span class="name">y</span> result])</div><div class="line">          (<span class="name"><span class="builtin-name">set!</span></span> temp-l (<span class="name"><span class="builtin-name">append</span></span> temp-l (<span class="name"><span class="builtin-name">list</span></span> (<span class="name"><span class="builtin-name">append</span></span> y (<span class="name"><span class="builtin-name">list</span></span> (<span class="name"><span class="builtin-name">car</span></span> l)))))))</div><div class="line">        (<span class="name"><span class="builtin-name">set!</span></span> result (<span class="name"><span class="builtin-name">append</span></span> result temp-l))</div><div class="line">        (<span class="name">powerset</span> (<span class="name"><span class="builtin-name">cdr</span></span> l) result))))</div></pre></td></tr></table></figure>
<p>循环和尾递归的互相转换是比较平滑的，这段尾递归代码就是我的最终答案，虽然中间还是用了一次 for ，但是这里无论用 for，还是用 map + lambda 都不能改变 powerset O(2^N) 最小时间复杂度的本质。</p>
<p>最后再看一看别人对这道题的答案，有一些代码又短又帅，可惜使用的是线性递归，例如:</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">powerset</span> lst)</div><div class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</div><div class="line">      '(())</div><div class="line">      (<span class="name">append-map</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x)</div><div class="line">                    (<span class="name"><span class="builtin-name">list</span></span> x (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">car</span></span> lst) x)))</div><div class="line">                  (<span class="name">powerset</span> (<span class="name"><span class="builtin-name">cdr</span></span> lst))))</div></pre></td></tr></table></figure>
<p>这种无比好看又容易爆栈的代码我凭第一直觉是绝对写不出来的，但是它们看上去真的很酷很干练。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;powerset 翻译成中文似乎是幂集，密集恐惧症患者搜索的时候要小心搜索引擎动态加载出来的图片。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用 Racket 递归实现 powerset , 顺序随意。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果说 reduce 是一种折
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Overkill for small efficiencies</title>
    <link href="http://yoursite.com/2016/11/30/overkill_for_small_efficiencies/"/>
    <id>http://yoursite.com/2016/11/30/overkill_for_small_efficiencies/</id>
    <published>2016-11-30T15:46:16.000Z</published>
    <updated>2016-12-01T05:27:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>由同事 review 我的代码时，建议我把 if-else 转换成 ternary operator 的方式，并表示这样可读性更强，进而引发出的一些联想和思考。我承认 <code>? :</code> 确实很酷，嵌套起来让别人比较难懂也是一种常用的炫技方式（雾），但是事实真的是这样嘛？</p>
<h6 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h6><p>令初学者津津乐道的 The zen of Python 里面有一句:</p>
<blockquote>
<p>There should be one– and preferably only one –obvious way to do it.</p>
</blockquote>
<p>于是年轻的刚接触 Python 的我，开始执迷于一些语言原生方法的执行效率问题。比如 list comprehension 是不是远好于 for loop ；而在 Python3 中几个 FP 方法变成了返回 iterator 的 lazy evaluation，是不是在大多数情况下又优于 list comprehension 了呢？于是时间被消耗在那些用 dis 反编译出来的字节码和数个测试样例上，以及最后得出了几乎永恒不变的结论：“虽然有一些 <del>negligible</del> 区别，但是仍然要考虑使用场景”。布道师和某些教程中会把这些东西当做噱头来讲，并表示这些真的很重要，那感觉就像是在说你不这样写程序就会崩溃、就不能成为合格的程序员一样。</p>
<p>认识一位程序员，当我问他关于两种写法的区别时，他永远会淡淡地对我说，一个省流量，一个省时间。因为绝大多数情况下他们的执行效率根本没有很大的差别（也可能他识破了我面对的量级太小），大到需要不顾一切地把代码里所有另一种写法全部替换掉。</p>
<p>类似的可读性和效率问题，大概连给银弹做火药粉末的资格都轮不到，更别提有没有了。</p>
<h6 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h6><blockquote>
<p>We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil.</p>
</blockquote>
<p>另一个问题就是时间成本的问题，程序员或多或少都会接触到一些优化执行效率的常识，比如一个后端查询，需要通过数据库取得数据之后返回给前端，那么（通常）把筛选集中到 io 操作即 SQL 语句中是一个比较好的方式。然而当筛选条件比较复杂时，这个举动就带来了许多问题：为了把所有的筛选集中到 SQL 中，需要面对 subquery 带来的局限性（诸如 <code>MySQL doesn&#39;t yet support &#39;LIMIT &amp; IN/ALL/ANY/SOME subquery</code>截止到 2016.11.29 MySQL 最新的 8.0 也仍然是不支持的）、数据库连接器或 ORM 对数据库操作的支持程度、代码的可读性、以及是否真的可以把所有筛选放到 SQL 中的问题等等（比如 left outer join multi rows 那糟糕的返回表现形式）。就算到了最后，你成功了，终于把筛选全部放入了 SQL 查询里，顺便鄙视了一下那个愚蠢地用某种后端语言对数据库查询结果进行过滤的方式，你很想看看花了这么久的时间写出的代码是不是碾压式地显著提高了执行效率，结果令你大失所望，并没有，起码在筛选后的数据处于万级以下是没有的，而且代码好难看，毕竟如果 SQL 好看，那么我们应该抛弃一切影响效率的 ORM，在代码中全部使用 raw SQL 语句了。显而易见地，为了并不知道有多少提升而无脑地进行所谓的效率优化，让我们失去了更多。</p>
<h6 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h6><p>winter 还没有自大地撕王垠、离开知乎之前，其实还是有一些可以看的答案的，比如：</p>
<blockquote>
<p>「答题基本只说一个名词，问深了得不到答案，挑战你的时候，又会快速推翻自己的结论，说做优化，又语焉不详，说不出来」</p>
</blockquote>
<p>我想大部分人提到 xxx 好、xxx 快的时候，大致也就如此了，这也合理，毕竟我们的日常也不是研读源码和优化效率，大部分的人的理论和决断是片面地来自于某篇技术文章或者某个技术分享。但我想如果你能引经据典的讲出差异，最好上几个 Gist 跑起来，强势证明一下自己的理论，那再好不过了。否则随便抓一个 StackOverflow 或者知乎上的一家之言并不能证明什么。</p>
<p>归根结底，了解它们的差异是有必要的，但是花费很多时间去纠结这些微小的执行效率、可读性的问题，甚至为了它们而争执起来，几乎是没有意义的，除非你从来不加班，也没有别的学习计划，又或者你的 title 只是代码细节优化工程师23333。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由同事 review 我的代码时，建议我把 if-else 转换成 ternary operator 的方式，并表示这样可读性更强，进而引发出的一些联想和思考。我承认 &lt;code&gt;? :&lt;/code&gt; 确实很酷，嵌套起来让别人比较难懂也是一种常用的炫技方式（雾），但是事实真
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Implement &quot;or&quot; operator in Elasticsearch</title>
    <link href="http://yoursite.com/2016/11/16/implement_or_operator_in_elasticsearch/"/>
    <id>http://yoursite.com/2016/11/16/implement_or_operator_in_elasticsearch/</id>
    <published>2016-11-16T07:46:16.000Z</published>
    <updated>2016-11-24T06:57:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容基于 Elasticsearch 2.0.1 。</p>
<p>首先是 <code>or filter</code> 已经变成了 <code>bool</code> ，它是专门用来合并 queries ，支持 or、and、not 这类操作符的，大概相当于 <code>()</code>(?).</p>
<ul>
<li><code>bool</code> 中的 <code>must</code> 就等于 SQL 中的 <code>AND</code></li>
<li>而 <code>should</code> 就相当于 SQL 中的 <code>OR</code></li>
<li><code>terms</code> 用来 match 任一出现在 simple type array (not object) 中的 doc</li>
</ul>
<p>当然还涉及到搜索结果评分等，但是这里不提这些。</p>
<p>现在遇到的情景大概就是想搜索多个空格分隔的关键字，任何一个 field 满足任一个关键字则匹配成功，返回所有匹配成功的结果和它们的 highlight 字段。</p>
<p>首先是对搜索内容做一点微不足道的处理:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> queries = <span class="string">'some keywords'</span>.trim().split(<span class="regexp">/\s+/</span>).map(<span class="function">(<span class="params">query</span>) =&gt;</span> query.lowerCase());</div><div class="line"><span class="keyword">const</span> queryString = queries.join(<span class="string">' OR '</span>);</div></pre></td></tr></table></figure>
<p>保持所有 query 包裹在 bool 中，把上面的两个变量用在 POST body 中，curl 同理:</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    "index": "index",</div><div class="line">    "from": 11,</div><div class="line">    "size": 20,</div><div class="line">    "_source": false,</div><div class="line">    "body": &#123;</div><div class="line">        "query": &#123;</div><div class="line">            "bool": &#123;</div><div class="line">            "should": [</div><div class="line">                &#123;</div><div class="line">                    "terms": &#123;</div><div class="line">                        "tags": queries,</div><div class="line">                    &#125;,</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                    "query_string": &#123;</div><div class="line">                        "query": queryString,</div><div class="line">                        "fields": ["name^5", "name.analyzed^5", "email", "phone", "content"],</div><div class="line">                        "analyzer": "whitespace",</div><div class="line">                    &#125;,</div><div class="line">                &#125;,</div><div class="line">            ],</div><div class="line">            "minimum_should_match": 1,</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        "highlight": &#123;</div><div class="line">            "fields": &#123;</div><div class="line">                "content": &#123; fragment_size: 18, number_of_fragments: 1 &#125;,</div><div class="line">                "name: &#123;&#125;,</div><div class="line">                "name.analyzed": &#123;&#125;,</div><div class="line">                "tags": &#123;&#125;,</div><div class="line">                "email": &#123;&#125;,</div><div class="line">                "phone": &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>note: <code>minimum_should_match</code> may not be available in some version of elasticsearch.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下内容基于 Elasticsearch 2.0.1 。&lt;/p&gt;
&lt;p&gt;首先是 &lt;code&gt;or filter&lt;/code&gt; 已经变成了 &lt;code&gt;bool&lt;/code&gt; ，它是专门用来合并 queries ，支持 or、and、not 这类操作符的，大概相当于 &lt;cod
    
    </summary>
    
    
  </entry>
  
</feed>
