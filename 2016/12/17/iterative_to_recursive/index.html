<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Iterative to Recursive</title><link rel="stylesheet" href="http://obfnm2kw5.bkt.clouddn.com/normalize.css"><link rel="stylesheet" href="/css/hexo-theme-adoubi.css"><link rel="icon" href="/images/favicon.ico"></head><body><div class="header"><div class="header__title"><a href="/"><figure class="header__title__image"></figure></a></div><div class="header__archive"><a href="/archives"><figure class="header__archive__image"></figure><span class="header__archive__title">archive</span></a></div><div class="header__about"><a href="/about"><figure class="header__about__image"></figure><span class="header__about__title">about</span></a></div><div class="header__github"><a href="https://github.com/shinux" target="_blank"><figure class="header__github__image"></figure><span class="header__github__title">github</span></a></div><div class="header__feed"><a href="/atom.xml"><figure class="header__feed__image"></figure><span class="header__feed__title">feed</span></a></div><div class="header__notes"></div></div><div class="content"><div class="post-item"></div><h2 class="post-title-wrapper"><p class="post-title">Iterative to Recursive</p></h2><div class="post-date"><time datetime="2016-12-17T15:46:16.000Z">2016-12-17</time></div><div class="post-content"><p>powerset 翻译成中文似乎是幂集，密集恐惧症患者搜索的时候要小心搜索引擎动态加载出来的图片。</p>
<blockquote>
<p>用 Racket 递归实现 powerset , 顺序随意。</p>
</blockquote>
<p>如果说 reduce 是一种向左折叠的操作，powerset 就有点类似的向右展开，首先想到的是用 Python 实现:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">powerset</span><span class="params">(_list)</span>:</span></div><div class="line">    result = [[]]</div><div class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> _list:</div><div class="line">        result.extend([_set + [x] <span class="keyword">for</span> _set <span class="keyword">in</span> result])</div><div class="line">    <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<p>太美了……当然题目要求用 Racket ，而且要求使用递归，而不是循环。</p>
<p>所以先翻译成循环的 Racket 版本:</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">powerset</span> l)</div><div class="line">  (<span class="name"><span class="builtin-name">define</span></span> result '(()))</div><div class="line">  (<span class="name">for</span> ([<span class="name">x</span> l])</div><div class="line">    (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">temp-l</span> '()])</div><div class="line">      (<span class="name">for</span> ([<span class="name">y</span> result])</div><div class="line">        (<span class="name"><span class="builtin-name">set!</span></span> temp-l (<span class="name"><span class="builtin-name">append</span></span> temp-l (<span class="name"><span class="builtin-name">list</span></span> (<span class="name"><span class="builtin-name">append</span></span> y (<span class="name"><span class="builtin-name">list</span></span> x))))))</div><div class="line">      (<span class="name"><span class="builtin-name">set!</span></span> result (<span class="name"><span class="builtin-name">append</span></span> result temp-l))))</div><div class="line">  result)</div></pre></td></tr></table></figure>
<p>基本上就是剥离了 list.extend 和 list comprehension 等 Python 内置方法，用 Racket 重写了一遍。其实循环挺好的，（对我来说）大部分场景比递归更直观，而且由于 Python 没有尾递归优化，导致我在很长一段的时间里不敢轻易在 Python 中使用递归233333。</p>
<p>把上面的循环改写成递归：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">powerset</span> l [<span class="name">result</span> '(())])</div><div class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> l) result</div><div class="line">      (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">temp-l</span> '()])</div><div class="line">        (<span class="name">for</span> ([<span class="name">y</span> result])</div><div class="line">          (<span class="name"><span class="builtin-name">set!</span></span> temp-l (<span class="name"><span class="builtin-name">append</span></span> temp-l (<span class="name"><span class="builtin-name">list</span></span> (<span class="name"><span class="builtin-name">append</span></span> y (<span class="name"><span class="builtin-name">list</span></span> (<span class="name"><span class="builtin-name">car</span></span> l)))))))</div><div class="line">        (<span class="name"><span class="builtin-name">set!</span></span> result (<span class="name"><span class="builtin-name">append</span></span> result temp-l))</div><div class="line">        (<span class="name">powerset</span> (<span class="name"><span class="builtin-name">cdr</span></span> l) result))))</div></pre></td></tr></table></figure>
<p>循环和尾递归的互相转换是比较平滑的，这段尾递归代码就是我的最终答案，虽然中间还是用了一次 for ，但是这里无论用 for，还是用 map + lambda 都不能改变 powerset O(2^N) 最小时间复杂度的本质。</p>
<p>最后再看一看别人对这道题的答案，有一些代码又短又帅，可惜使用的是线性递归，例如:</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">powerset</span> lst)</div><div class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</div><div class="line">      '(())</div><div class="line">      (<span class="name">append-map</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x)</div><div class="line">                    (<span class="name"><span class="builtin-name">list</span></span> x (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">car</span></span> lst) x)))</div><div class="line">                  (<span class="name">powerset</span> (<span class="name"><span class="builtin-name">cdr</span></span> lst))))</div></pre></td></tr></table></figure>
<p>这种无比好看又容易爆栈的代码我凭第一直觉是绝对写不出来的，但是它们看上去真的很酷很干练。</p>
</div></div><div class="footer"><div class="footer-copyright">Theme By <a href="https://github.com/shinux/hexo-theme-adoubi">Adoubi</a> , Powered By Hexo.</div></div></body></html>